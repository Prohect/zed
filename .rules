# Agent Environment Notes

Documents CLI tools and workflows for AI agents on projects.

## General Tool Usage Notes

- `grep` and `find_path` respect `.gitignore`; ignore gitignored files (e.g., `/target`, `/venv`); Symlinks are also ignored, intentional by git for windows
- `read_file` accesses gitignored files; use `start_line`/`end_line` for large files.
- Use project root prefix for gitignored files (e.g., `zed/...`); always find full paths before editing.
- For large files like outline.md (>40k lines, >1MB), use terminal `grep` with path limits instead of agent grep to avoid token waste; specify `-n` for line numbers and pipe to `head -20` for result limits.
- When searching in `outline.md`, prefer regex patterns like `find_all_references` or `references` to locate outline entries and their L-ranges for targeted `read_file` calls.
- To map an outline match at line N to its original source file, run:
  `awk 'NR <= N && /^## / { file = substr($0,4) } END { print file }' outline.md`
  This prints the nearest `## <file_path>` header above the match.
- Crucial: always supply both `start_line` AND `end_line` when calling `read_file`. Do NOT call `read_file` without `end_line` — large files (like `outline.md` and big source files) can return unbounded content and exhaust tokens. Use the outline's L-range or a bounded context window (for example, `start = match_start - 50`, `end = match_end + 50`) when reading source context.

## Agent Workflow Tips

### Bulk Refactoring (grep + sed)

For large code changes across files:

1. Use agent's grep to find patterns.
2. Use `sed` for batch find/replace in config/data files.
3. Use agent's edit tool for code logic changes.

Example: Reorder CSV fields in a config file more than 300 lines.
```sh
sed -i 's/^\([^#@*][^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\):\([^:]*\)$/\1:\3:\4:\5:\2:\6:\7/' config.ini
```

### Finding Rust Function Doc Ranges

Use `awk` to find doc start for Rust functions. Docs follow previous item's `}` or `;` .

Example: Find doc position for `foo`.
```sh
cd zed && awk '/^pub fn foo/ { print "Doc starts at " (last_end + 1); exit } /^}/ || /;$/ { last_end = NR }' src/fovo.rs
```

### Shell Escaping Issues

- Terminal uses `sh` (Git Bash).
- PowerShell `$_` interpreted by sh first.
- Prefer sed/perl/awk for complex one-liners.
- Use `.ps1` for complex PowerShell.

### Reading Context Around Grep Results

When grep finds a match (e.g., a field or function usage) without explicit line zone numbers in outline.md, read ±40 lines around the result to understand the surrounding code structure, such as the containing struct, impl block, or function. This helps identify exact line zones for targeted `read_file` calls.

Example: If grep finds "find_all_references_task_sources" at line 1041, read lines 1001-1081 to see the full `Editor` struct definition.

# Rust Coding Guidelines

- Prioritize correctness and clarity; speed secondary unless specified.
- Avoid summary comments; explain "why" only for non-obvious reasons.
- Implement in existing files unless new component; avoid many small files.
- Avoid panic functions like `unwrap()`; use `?` for error propagation.
- Avoid indexing panics; check bounds.
- Never discard errors with `let _ =`; handle appropriately:
  - Propagate with `?`.
  - Log with `.log_err()`.
  - Use match/if for custom logic.
  - Example: Avoid `let _ = client.request(...).await?;`; use `client.request(...).await?;`.
- Propagate async errors to UI for user feedback.
- Never use `mod.rs`; prefer `src/some_module.rs`.
- For new crates, specify lib path in Cargo.toml (e.g., `[lib] path = "gpui.rs"`).
- Avoid creative additions unless requested.
- Use full words for variables (no abbreviations).
- Use shadowing for clones in async contexts to minimize lifetimes.
  Example:
  ```rust
  executor.spawn({
      let task_ran = task_ran.clone();
      async move { *task_ran.borrow_mut() = true; }
  });
  ```

# Timers in Tests

- In GPUI tests, prefer GPUI executor timers over `smol::Timer::after(...)` for timeouts/delays/`run_until_parked()`.
- Use `cx.background_executor().timer(duration).await` (or `cx.background_executor.timer(duration).await` in TestAppContext).
- Avoid `smol::Timer::after(...)` for test timeouts relying on `run_until_parked()`; may not be tracked by GPUI scheduler.

# GPUI

GPUI: UI framework with state/concurrency primitives.

## Context

Contexts for global state, windows, entities, services. Passed as `cx`.

- `App`: Root context; access global state, entities.
- `Context<T>`: For updating `Entity<T>`; derefs to `App`.
- `AsyncApp`, `AsyncWindowContext`: From `cx.spawn`, `cx.spawn_in`; hold across awaits.

## Window

`Window`: Access window state. Passed as `window` before `cx`. Manages focus, actions, drawing, input.

## Entities

`Entity<T>`: Handle to state `T`.

- `thing.entity_id()`: `EntityId`.
- `thing.downgrade()`: `WeakEntity<T>`.
- `thing.read(cx: &App)`: `&T`.
- `thing.read_with(cx, |thing: &T, cx: &App| ...)`: Closure return.
- `thing.update(cx, |thing: &mut T, cx: &mut Context<T>| ...)`: Mutate state; returns closure return.
- `thing.update_in(cx, |thing: &mut T, window: &mut Window, cx: &mut Context<T>| ...)`: With `Window`; for `AsyncWindowContext`/`VisualTestContext`.

Use inner `cx` in closures to avoid borrow issues. Avoid updating during update (panics).

`WeakEntity<T>`: Weak handle. Methods return `Result`; fail if entity gone. Prevents leaks.

## Concurrency

All entity/UI on single foreground thread.

`cx.spawn(async move |cx| ...)`: Run async closure on foreground. `cx` is `AsyncApp`/`AsyncWindowContext`.

For `Context<T>`: `cx.spawn(async move |handle, cx| ...)` where `handle: WeakEntity<T>`.

`cx.background_spawn(async move { ... })`: Work on other threads. Await in foreground to update.

Both return `Task<R>` (future). Drop cancels. Prevent by awaiting, detaching (`task.detach()`/`detach_and_log_err(cx)`), or storing.

`Task::ready(value)`: Ready task.

## Elements

`Render` trait: Render state to element tree (flexbox).

`Entity<T>` with `Render`: "view".

Example:
```rust
struct TextWithBorder(SharedString);

impl Render for TextWithBorder {
    fn render(&mut self, _window: &mut Window, _cx: &mut Context<Self>) -> impl IntoElement {
        div().border_1().child(self.0.clone())
    }
}
```

`SharedString`: Avoid copies; `&'static str` or `Arc<str>`.

`RenderOnce`: For one-time elements; use `#[derive(IntoElement)]`.

Styles like Tailwind.

Conditional: `.when(condition, |this| ...)`, `.when_some(option, |this, value| ...)`.

## Input Events

Handlers: `.on_click(|event, window, cx: &mut App| ...)`.

For entity update: `.on_click(cx.listener(|this: &mut T, event, window, cx: &mut Context<T>| ...))`.

## Actions

Dispatch: `window.dispatch_action(SomeAction.boxed_clone(), cx)` or `focus_handle.dispatch_action(&SomeAction, window, cx)`.

Define: `actions!(namespace, [Action])` or `#[derive(Action)]`.

Handlers: `.on_action(|action, window, cx| ...)`. Often with `cx.listener`.

## Notify

Call `cx.notify()` on state change affecting render. Triggers rerender and observe callbacks.

## Entity Events

Emit: `cx.emit(event)` in update. Declare `impl EventEmitter<EventType> for EntityType {}`.

Subscribe: `cx.subscribe(other_entity, |this, other_entity, event, cx| ...)`. Returns `Subscription`; drop deregisters. Store in `_subscriptions: Vec<Subscription>`.

## Recent API Changes

Use new APIs:

- `spawn` takes async closures: `cx.spawn(async move |cx| ...)`.
- Use `Entity<T>` (not `Model<T>`/`View<T>`).
- Use `App` refs (not `AppContext`).
- Use `Context<T>` refs (not `ModelContext<T>`).
- `Window` explicit. New "*_in" methods. Avoid `WindowContext`/`ViewContext<T>`.

## General Guidelines

- Use `./script/clippy` instead of `cargo clippy`.
